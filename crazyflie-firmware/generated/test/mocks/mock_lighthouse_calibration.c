/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_lighthouse_calibration.h"

static const char* CMockString_calib = "calib";
static const char* CMockString_correctedAngles = "correctedAngles";
static const char* CMockString_frame = "frame";
static const char* CMockString_lighthouseCalibrationApplyNothing = "lighthouseCalibrationApplyNothing";
static const char* CMockString_lighthouseCalibrationApplyV1 = "lighthouseCalibrationApplyV1";
static const char* CMockString_lighthouseCalibrationApplyV2 = "lighthouseCalibrationApplyV2";
static const char* CMockString_lighthouseCalibrationInitFromFrame = "lighthouseCalibrationInitFromFrame";
static const char* CMockString_lighthouseCalibrationMeasurementModelLh1 = "lighthouseCalibrationMeasurementModelLh1";
static const char* CMockString_lighthouseCalibrationMeasurementModelLh2 = "lighthouseCalibrationMeasurementModelLh2";
static const char* CMockString_rawAngles = "rawAngles";
static const char* CMockString_t = "t";
static const char* CMockString_x = "x";
static const char* CMockString_y = "y";
static const char* CMockString_z = "z";

typedef struct _CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lighthouseCalibration_t* Expected_calib;
  struct ootxDataFrame_s* Expected_frame;
  int Expected_calib_Depth;
  int Expected_frame_Depth;
  int IgnoreArg_calib;
  int IgnoreArg_frame;

} CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const lighthouseCalibration_t* Expected_calib;
  const float* Expected_rawAngles;
  float* Expected_correctedAngles;
  int Expected_calib_Depth;
  int Expected_rawAngles_Depth;
  int Expected_correctedAngles_Depth;
  int IgnoreArg_calib;
  int IgnoreArg_rawAngles;
  int IgnoreArg_correctedAngles;

} CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const lighthouseCalibration_t* Expected_calib;
  const float* Expected_rawAngles;
  float* Expected_correctedAngles;
  int Expected_calib_Depth;
  int Expected_rawAngles_Depth;
  int Expected_correctedAngles_Depth;
  int IgnoreArg_calib;
  int IgnoreArg_rawAngles;
  int IgnoreArg_correctedAngles;

} CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const float* Expected_rawAngles;
  float* Expected_correctedAngles;
  int Expected_rawAngles_Depth;
  int Expected_correctedAngles_Depth;
  int IgnoreArg_rawAngles;
  int IgnoreArg_correctedAngles;

} CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  float ReturnVal;
  float Expected_x;
  float Expected_y;
  float Expected_z;
  float Expected_t;
  const lighthouseCalibrationSweep_t* Expected_calib;
  int Expected_calib_Depth;
  int IgnoreArg_x;
  int IgnoreArg_y;
  int IgnoreArg_z;
  int IgnoreArg_t;
  int IgnoreArg_calib;

} CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  float ReturnVal;
  float Expected_x;
  float Expected_y;
  float Expected_z;
  float Expected_t;
  const lighthouseCalibrationSweep_t* Expected_calib;
  int Expected_calib_Depth;
  int IgnoreArg_x;
  int IgnoreArg_y;
  int IgnoreArg_z;
  int IgnoreArg_t;
  int IgnoreArg_calib;

} CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE;

static struct mock_lighthouse_calibrationInstance
{
  int lighthouseCalibrationInitFromFrame_IgnoreBool;
  CMOCK_lighthouseCalibrationInitFromFrame_CALLBACK lighthouseCalibrationInitFromFrame_CallbackFunctionPointer;
  int lighthouseCalibrationInitFromFrame_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseCalibrationInitFromFrame_CallInstance;
  int lighthouseCalibrationApplyV1_IgnoreBool;
  CMOCK_lighthouseCalibrationApplyV1_CALLBACK lighthouseCalibrationApplyV1_CallbackFunctionPointer;
  int lighthouseCalibrationApplyV1_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseCalibrationApplyV1_CallInstance;
  int lighthouseCalibrationApplyV2_IgnoreBool;
  CMOCK_lighthouseCalibrationApplyV2_CALLBACK lighthouseCalibrationApplyV2_CallbackFunctionPointer;
  int lighthouseCalibrationApplyV2_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseCalibrationApplyV2_CallInstance;
  int lighthouseCalibrationApplyNothing_IgnoreBool;
  CMOCK_lighthouseCalibrationApplyNothing_CALLBACK lighthouseCalibrationApplyNothing_CallbackFunctionPointer;
  int lighthouseCalibrationApplyNothing_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseCalibrationApplyNothing_CallInstance;
  int lighthouseCalibrationMeasurementModelLh1_IgnoreBool;
  float lighthouseCalibrationMeasurementModelLh1_FinalReturn;
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALLBACK lighthouseCalibrationMeasurementModelLh1_CallbackFunctionPointer;
  int lighthouseCalibrationMeasurementModelLh1_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseCalibrationMeasurementModelLh1_CallInstance;
  int lighthouseCalibrationMeasurementModelLh2_IgnoreBool;
  float lighthouseCalibrationMeasurementModelLh2_FinalReturn;
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALLBACK lighthouseCalibrationMeasurementModelLh2_CallbackFunctionPointer;
  int lighthouseCalibrationMeasurementModelLh2_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseCalibrationMeasurementModelLh2_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_lighthouse_calibration_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.lighthouseCalibrationInitFromFrame_IgnoreBool)
    Mock.lighthouseCalibrationInitFromFrame_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationInitFromFrame);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseCalibrationInitFromFrame_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseCalibrationInitFromFrame_CallbackFunctionPointer != NULL)
    Mock.lighthouseCalibrationInitFromFrame_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseCalibrationApplyV1_IgnoreBool)
    Mock.lighthouseCalibrationApplyV1_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationApplyV1);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseCalibrationApplyV1_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseCalibrationApplyV1_CallbackFunctionPointer != NULL)
    Mock.lighthouseCalibrationApplyV1_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseCalibrationApplyV2_IgnoreBool)
    Mock.lighthouseCalibrationApplyV2_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationApplyV2);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseCalibrationApplyV2_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseCalibrationApplyV2_CallbackFunctionPointer != NULL)
    Mock.lighthouseCalibrationApplyV2_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseCalibrationApplyNothing_IgnoreBool)
    Mock.lighthouseCalibrationApplyNothing_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationApplyNothing);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseCalibrationApplyNothing_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseCalibrationApplyNothing_CallbackFunctionPointer != NULL)
    Mock.lighthouseCalibrationApplyNothing_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool)
    Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationMeasurementModelLh1);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseCalibrationMeasurementModelLh1_CallbackFunctionPointer != NULL)
    Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool)
    Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationMeasurementModelLh2);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseCalibrationMeasurementModelLh2_CallbackFunctionPointer != NULL)
    Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance = CMOCK_GUTS_NONE;
}

void mock_lighthouse_calibration_Init(void)
{
  mock_lighthouse_calibration_Destroy();
}

void mock_lighthouse_calibration_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.lighthouseCalibrationInitFromFrame_CallbackFunctionPointer = NULL;
  Mock.lighthouseCalibrationInitFromFrame_CallbackCalls = 0;
  Mock.lighthouseCalibrationApplyV1_CallbackFunctionPointer = NULL;
  Mock.lighthouseCalibrationApplyV1_CallbackCalls = 0;
  Mock.lighthouseCalibrationApplyV2_CallbackFunctionPointer = NULL;
  Mock.lighthouseCalibrationApplyV2_CallbackCalls = 0;
  Mock.lighthouseCalibrationApplyNothing_CallbackFunctionPointer = NULL;
  Mock.lighthouseCalibrationApplyNothing_CallbackCalls = 0;
  Mock.lighthouseCalibrationMeasurementModelLh1_CallbackFunctionPointer = NULL;
  Mock.lighthouseCalibrationMeasurementModelLh1_CallbackCalls = 0;
  Mock.lighthouseCalibrationMeasurementModelLh2_CallbackFunctionPointer = NULL;
  Mock.lighthouseCalibrationMeasurementModelLh2_CallbackCalls = 0;
}

void lighthouseCalibrationInitFromFrame(lighthouseCalibration_t* calib, struct ootxDataFrame_s* frame)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationInitFromFrame);
  cmock_call_instance = (CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseCalibrationInitFromFrame_CallInstance);
  Mock.lighthouseCalibrationInitFromFrame_CallInstance = CMock_Guts_MemNext(Mock.lighthouseCalibrationInitFromFrame_CallInstance);
  if (Mock.lighthouseCalibrationInitFromFrame_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthouseCalibrationInitFromFrame_CallbackFunctionPointer != NULL)
  {
    Mock.lighthouseCalibrationInitFromFrame_CallbackFunctionPointer(calib, frame, Mock.lighthouseCalibrationInitFromFrame_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_calib)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationInitFromFrame,CMockString_calib);
    if (cmock_call_instance->Expected_calib == NULL)
      { UNITY_TEST_ASSERT_NULL(calib, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_calib), (void*)(calib), sizeof(lighthouseCalibration_t), cmock_call_instance->Expected_calib_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_frame)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationInitFromFrame,CMockString_frame);
    if (cmock_call_instance->Expected_frame == NULL)
      { UNITY_TEST_ASSERT_NULL(frame, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_frame), (void*)(frame), sizeof(struct ootxDataFrame_s), cmock_call_instance->Expected_frame_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthouseCalibrationInitFromFrame(CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE* cmock_call_instance, lighthouseCalibration_t* calib, int calib_Depth, struct ootxDataFrame_s* frame, int frame_Depth)
{
  cmock_call_instance->Expected_calib = calib;
  cmock_call_instance->Expected_calib_Depth = calib_Depth;
  cmock_call_instance->IgnoreArg_calib = 0;
  cmock_call_instance->Expected_frame = frame;
  cmock_call_instance->Expected_frame_Depth = frame_Depth;
  cmock_call_instance->IgnoreArg_frame = 0;
}

void lighthouseCalibrationInitFromFrame_CMockIgnore(void)
{
  Mock.lighthouseCalibrationInitFromFrame_IgnoreBool = (int)1;
}

void lighthouseCalibrationInitFromFrame_CMockExpect(UNITY_LINE_TYPE cmock_line, lighthouseCalibration_t* calib, struct ootxDataFrame_s* frame)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationInitFromFrame_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationInitFromFrame_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationInitFromFrame_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationInitFromFrame(cmock_call_instance, calib, 1, frame, 1);
  UNITY_CLR_DETAILS();
}

void lighthouseCalibrationInitFromFrame_StubWithCallback(CMOCK_lighthouseCalibrationInitFromFrame_CALLBACK Callback)
{
  Mock.lighthouseCalibrationInitFromFrame_IgnoreBool = (int)0;
  Mock.lighthouseCalibrationInitFromFrame_CallbackFunctionPointer = Callback;
}

void lighthouseCalibrationInitFromFrame_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, lighthouseCalibration_t* calib, int calib_Depth, struct ootxDataFrame_s* frame, int frame_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationInitFromFrame_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationInitFromFrame_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationInitFromFrame_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationInitFromFrame(cmock_call_instance, calib, calib_Depth, frame, frame_Depth);
}

void lighthouseCalibrationInitFromFrame_CMockIgnoreArg_calib(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationInitFromFrame_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_calib = 1;
}

void lighthouseCalibrationInitFromFrame_CMockIgnoreArg_frame(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationInitFromFrame_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationInitFromFrame_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_frame = 1;
}

void lighthouseCalibrationApplyV1(const lighthouseCalibration_t* calib, const float* rawAngles, float* correctedAngles)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationApplyV1);
  cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseCalibrationApplyV1_CallInstance);
  Mock.lighthouseCalibrationApplyV1_CallInstance = CMock_Guts_MemNext(Mock.lighthouseCalibrationApplyV1_CallInstance);
  if (Mock.lighthouseCalibrationApplyV1_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthouseCalibrationApplyV1_CallbackFunctionPointer != NULL)
  {
    Mock.lighthouseCalibrationApplyV1_CallbackFunctionPointer(calib, rawAngles, correctedAngles, Mock.lighthouseCalibrationApplyV1_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_calib)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyV1,CMockString_calib);
    if (cmock_call_instance->Expected_calib == NULL)
      { UNITY_TEST_ASSERT_NULL(calib, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_calib), (void*)(calib), sizeof(const lighthouseCalibration_t), cmock_call_instance->Expected_calib_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_rawAngles)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyV1,CMockString_rawAngles);
    if (cmock_call_instance->Expected_rawAngles == NULL)
      { UNITY_TEST_ASSERT_NULL(rawAngles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_rawAngles, rawAngles, cmock_call_instance->Expected_rawAngles_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_correctedAngles)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyV1,CMockString_correctedAngles);
    if (cmock_call_instance->Expected_correctedAngles == NULL)
      { UNITY_TEST_ASSERT_NULL(correctedAngles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_correctedAngles, correctedAngles, cmock_call_instance->Expected_correctedAngles_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthouseCalibrationApplyV1(CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance, const lighthouseCalibration_t* calib, int calib_Depth, const float* rawAngles, int rawAngles_Depth, float* correctedAngles, int correctedAngles_Depth)
{
  cmock_call_instance->Expected_calib = calib;
  cmock_call_instance->Expected_calib_Depth = calib_Depth;
  cmock_call_instance->IgnoreArg_calib = 0;
  cmock_call_instance->Expected_rawAngles = rawAngles;
  cmock_call_instance->Expected_rawAngles_Depth = rawAngles_Depth;
  cmock_call_instance->IgnoreArg_rawAngles = 0;
  cmock_call_instance->Expected_correctedAngles = correctedAngles;
  cmock_call_instance->Expected_correctedAngles_Depth = correctedAngles_Depth;
  cmock_call_instance->IgnoreArg_correctedAngles = 0;
}

void lighthouseCalibrationApplyV1_CMockIgnore(void)
{
  Mock.lighthouseCalibrationApplyV1_IgnoreBool = (int)1;
}

void lighthouseCalibrationApplyV1_CMockExpect(UNITY_LINE_TYPE cmock_line, const lighthouseCalibration_t* calib, const float* rawAngles, float* correctedAngles)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationApplyV1_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationApplyV1_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationApplyV1_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationApplyV1(cmock_call_instance, calib, 1, rawAngles, 1, correctedAngles, 1);
  UNITY_CLR_DETAILS();
}

void lighthouseCalibrationApplyV1_StubWithCallback(CMOCK_lighthouseCalibrationApplyV1_CALLBACK Callback)
{
  Mock.lighthouseCalibrationApplyV1_IgnoreBool = (int)0;
  Mock.lighthouseCalibrationApplyV1_CallbackFunctionPointer = Callback;
}

void lighthouseCalibrationApplyV1_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const lighthouseCalibration_t* calib, int calib_Depth, const float* rawAngles, int rawAngles_Depth, float* correctedAngles, int correctedAngles_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationApplyV1_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationApplyV1_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationApplyV1_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationApplyV1(cmock_call_instance, calib, calib_Depth, rawAngles, rawAngles_Depth, correctedAngles, correctedAngles_Depth);
}

void lighthouseCalibrationApplyV1_CMockIgnoreArg_calib(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyV1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_calib = 1;
}

void lighthouseCalibrationApplyV1_CMockIgnoreArg_rawAngles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyV1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_rawAngles = 1;
}

void lighthouseCalibrationApplyV1_CMockIgnoreArg_correctedAngles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyV1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_correctedAngles = 1;
}

void lighthouseCalibrationApplyV2(const lighthouseCalibration_t* calib, const float* rawAngles, float* correctedAngles)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationApplyV2);
  cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseCalibrationApplyV2_CallInstance);
  Mock.lighthouseCalibrationApplyV2_CallInstance = CMock_Guts_MemNext(Mock.lighthouseCalibrationApplyV2_CallInstance);
  if (Mock.lighthouseCalibrationApplyV2_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthouseCalibrationApplyV2_CallbackFunctionPointer != NULL)
  {
    Mock.lighthouseCalibrationApplyV2_CallbackFunctionPointer(calib, rawAngles, correctedAngles, Mock.lighthouseCalibrationApplyV2_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_calib)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyV2,CMockString_calib);
    if (cmock_call_instance->Expected_calib == NULL)
      { UNITY_TEST_ASSERT_NULL(calib, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_calib), (void*)(calib), sizeof(const lighthouseCalibration_t), cmock_call_instance->Expected_calib_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_rawAngles)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyV2,CMockString_rawAngles);
    if (cmock_call_instance->Expected_rawAngles == NULL)
      { UNITY_TEST_ASSERT_NULL(rawAngles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_rawAngles, rawAngles, cmock_call_instance->Expected_rawAngles_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_correctedAngles)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyV2,CMockString_correctedAngles);
    if (cmock_call_instance->Expected_correctedAngles == NULL)
      { UNITY_TEST_ASSERT_NULL(correctedAngles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_correctedAngles, correctedAngles, cmock_call_instance->Expected_correctedAngles_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthouseCalibrationApplyV2(CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance, const lighthouseCalibration_t* calib, int calib_Depth, const float* rawAngles, int rawAngles_Depth, float* correctedAngles, int correctedAngles_Depth)
{
  cmock_call_instance->Expected_calib = calib;
  cmock_call_instance->Expected_calib_Depth = calib_Depth;
  cmock_call_instance->IgnoreArg_calib = 0;
  cmock_call_instance->Expected_rawAngles = rawAngles;
  cmock_call_instance->Expected_rawAngles_Depth = rawAngles_Depth;
  cmock_call_instance->IgnoreArg_rawAngles = 0;
  cmock_call_instance->Expected_correctedAngles = correctedAngles;
  cmock_call_instance->Expected_correctedAngles_Depth = correctedAngles_Depth;
  cmock_call_instance->IgnoreArg_correctedAngles = 0;
}

void lighthouseCalibrationApplyV2_CMockIgnore(void)
{
  Mock.lighthouseCalibrationApplyV2_IgnoreBool = (int)1;
}

void lighthouseCalibrationApplyV2_CMockExpect(UNITY_LINE_TYPE cmock_line, const lighthouseCalibration_t* calib, const float* rawAngles, float* correctedAngles)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationApplyV2_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationApplyV2_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationApplyV2_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationApplyV2(cmock_call_instance, calib, 1, rawAngles, 1, correctedAngles, 1);
  UNITY_CLR_DETAILS();
}

void lighthouseCalibrationApplyV2_StubWithCallback(CMOCK_lighthouseCalibrationApplyV2_CALLBACK Callback)
{
  Mock.lighthouseCalibrationApplyV2_IgnoreBool = (int)0;
  Mock.lighthouseCalibrationApplyV2_CallbackFunctionPointer = Callback;
}

void lighthouseCalibrationApplyV2_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const lighthouseCalibration_t* calib, int calib_Depth, const float* rawAngles, int rawAngles_Depth, float* correctedAngles, int correctedAngles_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationApplyV2_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationApplyV2_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationApplyV2_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationApplyV2(cmock_call_instance, calib, calib_Depth, rawAngles, rawAngles_Depth, correctedAngles, correctedAngles_Depth);
}

void lighthouseCalibrationApplyV2_CMockIgnoreArg_calib(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyV2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_calib = 1;
}

void lighthouseCalibrationApplyV2_CMockIgnoreArg_rawAngles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyV2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_rawAngles = 1;
}

void lighthouseCalibrationApplyV2_CMockIgnoreArg_correctedAngles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyV2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyV2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_correctedAngles = 1;
}

void lighthouseCalibrationApplyNothing(const float* rawAngles, float* correctedAngles)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationApplyNothing);
  cmock_call_instance = (CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseCalibrationApplyNothing_CallInstance);
  Mock.lighthouseCalibrationApplyNothing_CallInstance = CMock_Guts_MemNext(Mock.lighthouseCalibrationApplyNothing_CallInstance);
  if (Mock.lighthouseCalibrationApplyNothing_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthouseCalibrationApplyNothing_CallbackFunctionPointer != NULL)
  {
    Mock.lighthouseCalibrationApplyNothing_CallbackFunctionPointer(rawAngles, correctedAngles, Mock.lighthouseCalibrationApplyNothing_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_rawAngles)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyNothing,CMockString_rawAngles);
    if (cmock_call_instance->Expected_rawAngles == NULL)
      { UNITY_TEST_ASSERT_NULL(rawAngles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_rawAngles, rawAngles, cmock_call_instance->Expected_rawAngles_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_correctedAngles)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationApplyNothing,CMockString_correctedAngles);
    if (cmock_call_instance->Expected_correctedAngles == NULL)
      { UNITY_TEST_ASSERT_NULL(correctedAngles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_correctedAngles, correctedAngles, cmock_call_instance->Expected_correctedAngles_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthouseCalibrationApplyNothing(CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE* cmock_call_instance, const float* rawAngles, int rawAngles_Depth, float* correctedAngles, int correctedAngles_Depth)
{
  cmock_call_instance->Expected_rawAngles = rawAngles;
  cmock_call_instance->Expected_rawAngles_Depth = rawAngles_Depth;
  cmock_call_instance->IgnoreArg_rawAngles = 0;
  cmock_call_instance->Expected_correctedAngles = correctedAngles;
  cmock_call_instance->Expected_correctedAngles_Depth = correctedAngles_Depth;
  cmock_call_instance->IgnoreArg_correctedAngles = 0;
}

void lighthouseCalibrationApplyNothing_CMockIgnore(void)
{
  Mock.lighthouseCalibrationApplyNothing_IgnoreBool = (int)1;
}

void lighthouseCalibrationApplyNothing_CMockExpect(UNITY_LINE_TYPE cmock_line, const float* rawAngles, float* correctedAngles)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationApplyNothing_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationApplyNothing_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationApplyNothing_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationApplyNothing(cmock_call_instance, rawAngles, 1, correctedAngles, 1);
  UNITY_CLR_DETAILS();
}

void lighthouseCalibrationApplyNothing_StubWithCallback(CMOCK_lighthouseCalibrationApplyNothing_CALLBACK Callback)
{
  Mock.lighthouseCalibrationApplyNothing_IgnoreBool = (int)0;
  Mock.lighthouseCalibrationApplyNothing_CallbackFunctionPointer = Callback;
}

void lighthouseCalibrationApplyNothing_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const float* rawAngles, int rawAngles_Depth, float* correctedAngles, int correctedAngles_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationApplyNothing_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationApplyNothing_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationApplyNothing_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationApplyNothing(cmock_call_instance, rawAngles, rawAngles_Depth, correctedAngles, correctedAngles_Depth);
}

void lighthouseCalibrationApplyNothing_CMockIgnoreArg_rawAngles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyNothing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_rawAngles = 1;
}

void lighthouseCalibrationApplyNothing_CMockIgnoreArg_correctedAngles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationApplyNothing_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationApplyNothing_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_correctedAngles = 1;
}

float lighthouseCalibrationMeasurementModelLh1(const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationMeasurementModelLh1);
  cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance);
  Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance = CMock_Guts_MemNext(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance);
  if (Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lighthouseCalibrationMeasurementModelLh1_FinalReturn;
    Mock.lighthouseCalibrationMeasurementModelLh1_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.lighthouseCalibrationMeasurementModelLh1_CallbackFunctionPointer != NULL)
  {
    return Mock.lighthouseCalibrationMeasurementModelLh1_CallbackFunctionPointer(x, y, z, t, calib, Mock.lighthouseCalibrationMeasurementModelLh1_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_x)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh1,CMockString_x);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_x, x, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_y)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh1,CMockString_y);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_y, y, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_z)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh1,CMockString_z);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_z, z, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_t)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh1,CMockString_t);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_t, t, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_calib)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh1,CMockString_calib);
    if (cmock_call_instance->Expected_calib == NULL)
      { UNITY_TEST_ASSERT_NULL(calib, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_calib), (void*)(calib), sizeof(const lighthouseCalibrationSweep_t), cmock_call_instance->Expected_calib_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lighthouseCalibrationMeasurementModelLh1(CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance, const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib, int calib_Depth)
{
  cmock_call_instance->Expected_x = x;
  cmock_call_instance->IgnoreArg_x = 0;
  cmock_call_instance->Expected_y = y;
  cmock_call_instance->IgnoreArg_y = 0;
  cmock_call_instance->Expected_z = z;
  cmock_call_instance->IgnoreArg_z = 0;
  cmock_call_instance->Expected_t = t;
  cmock_call_instance->IgnoreArg_t = 0;
  cmock_call_instance->Expected_calib = calib;
  cmock_call_instance->Expected_calib_Depth = calib_Depth;
  cmock_call_instance->IgnoreArg_calib = 0;
}

void lighthouseCalibrationMeasurementModelLh1_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool = (int)1;
}

void lighthouseCalibrationMeasurementModelLh1_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationMeasurementModelLh1(cmock_call_instance, x, y, z, t, calib, 1);
  cmock_call_instance->ReturnVal = cmock_to_return;
  UNITY_CLR_DETAILS();
}

void lighthouseCalibrationMeasurementModelLh1_StubWithCallback(CMOCK_lighthouseCalibrationMeasurementModelLh1_CALLBACK Callback)
{
  Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool = (int)0;
  Mock.lighthouseCalibrationMeasurementModelLh1_CallbackFunctionPointer = Callback;
}

void lighthouseCalibrationMeasurementModelLh1_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib, int calib_Depth, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationMeasurementModelLh1_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationMeasurementModelLh1(cmock_call_instance, x, y, z, t, calib, calib_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lighthouseCalibrationMeasurementModelLh1_CMockIgnoreArg_x(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_x = 1;
}

void lighthouseCalibrationMeasurementModelLh1_CMockIgnoreArg_y(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_y = 1;
}

void lighthouseCalibrationMeasurementModelLh1_CMockIgnoreArg_z(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_z = 1;
}

void lighthouseCalibrationMeasurementModelLh1_CMockIgnoreArg_t(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_t = 1;
}

void lighthouseCalibrationMeasurementModelLh1_CMockIgnoreArg_calib(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh1_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_calib = 1;
}

float lighthouseCalibrationMeasurementModelLh2(const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseCalibrationMeasurementModelLh2);
  cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance);
  Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance = CMock_Guts_MemNext(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance);
  if (Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lighthouseCalibrationMeasurementModelLh2_FinalReturn;
    Mock.lighthouseCalibrationMeasurementModelLh2_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.lighthouseCalibrationMeasurementModelLh2_CallbackFunctionPointer != NULL)
  {
    return Mock.lighthouseCalibrationMeasurementModelLh2_CallbackFunctionPointer(x, y, z, t, calib, Mock.lighthouseCalibrationMeasurementModelLh2_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_x)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh2,CMockString_x);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_x, x, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_y)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh2,CMockString_y);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_y, y, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_z)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh2,CMockString_z);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_z, z, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_t)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh2,CMockString_t);
    UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_t, t, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_calib)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseCalibrationMeasurementModelLh2,CMockString_calib);
    if (cmock_call_instance->Expected_calib == NULL)
      { UNITY_TEST_ASSERT_NULL(calib, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_calib), (void*)(calib), sizeof(const lighthouseCalibrationSweep_t), cmock_call_instance->Expected_calib_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lighthouseCalibrationMeasurementModelLh2(CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance, const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib, int calib_Depth)
{
  cmock_call_instance->Expected_x = x;
  cmock_call_instance->IgnoreArg_x = 0;
  cmock_call_instance->Expected_y = y;
  cmock_call_instance->IgnoreArg_y = 0;
  cmock_call_instance->Expected_z = z;
  cmock_call_instance->IgnoreArg_z = 0;
  cmock_call_instance->Expected_t = t;
  cmock_call_instance->IgnoreArg_t = 0;
  cmock_call_instance->Expected_calib = calib;
  cmock_call_instance->Expected_calib_Depth = calib_Depth;
  cmock_call_instance->IgnoreArg_calib = 0;
}

void lighthouseCalibrationMeasurementModelLh2_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool = (int)1;
}

void lighthouseCalibrationMeasurementModelLh2_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationMeasurementModelLh2(cmock_call_instance, x, y, z, t, calib, 1);
  cmock_call_instance->ReturnVal = cmock_to_return;
  UNITY_CLR_DETAILS();
}

void lighthouseCalibrationMeasurementModelLh2_StubWithCallback(CMOCK_lighthouseCalibrationMeasurementModelLh2_CALLBACK Callback)
{
  Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool = (int)0;
  Mock.lighthouseCalibrationMeasurementModelLh2_CallbackFunctionPointer = Callback;
}

void lighthouseCalibrationMeasurementModelLh2_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const float x, const float y, const float z, const float t, const lighthouseCalibrationSweep_t* calib, int calib_Depth, float cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE));
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance = CMock_Guts_MemChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance, cmock_guts_index);
  Mock.lighthouseCalibrationMeasurementModelLh2_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseCalibrationMeasurementModelLh2(cmock_call_instance, x, y, z, t, calib, calib_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lighthouseCalibrationMeasurementModelLh2_CMockIgnoreArg_x(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_x = 1;
}

void lighthouseCalibrationMeasurementModelLh2_CMockIgnoreArg_y(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_y = 1;
}

void lighthouseCalibrationMeasurementModelLh2_CMockIgnoreArg_z(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_z = 1;
}

void lighthouseCalibrationMeasurementModelLh2_CMockIgnoreArg_t(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_t = 1;
}

void lighthouseCalibrationMeasurementModelLh2_CMockIgnoreArg_calib(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseCalibrationMeasurementModelLh2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseCalibrationMeasurementModelLh2_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_calib = 1;
}

