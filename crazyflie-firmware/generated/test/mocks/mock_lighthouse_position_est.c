/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_lighthouse_position_est.h"

static const char* CMockString_angles = "angles";
static const char* CMockString_baseStation = "baseStation";
static const char* CMockString_baseStation1 = "baseStation1";
static const char* CMockString_baseStation2 = "baseStation2";
static const char* CMockString_geometry = "geometry";
static const char* CMockString_lighthousePositionCalibrationDataWritten = "lighthousePositionCalibrationDataWritten";
static const char* CMockString_lighthousePositionEstInit = "lighthousePositionEstInit";
static const char* CMockString_lighthousePositionEstimatePoseCrossingBeams = "lighthousePositionEstimatePoseCrossingBeams";
static const char* CMockString_lighthousePositionEstimatePoseSweeps = "lighthousePositionEstimatePoseSweeps";
static const char* CMockString_lighthousePositionSetGeometryData = "lighthousePositionSetGeometryData";
static const char* CMockString_state = "state";

typedef struct _CMOCK_lighthousePositionEstInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_lighthousePositionEstInit_CALL_INSTANCE;

typedef struct _CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t Expected_baseStation;
  const baseStationGeometry_t* Expected_geometry;
  int Expected_geometry_Depth;
  int IgnoreArg_baseStation;
  int IgnoreArg_geometry;

} CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE;

typedef struct _CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t Expected_baseStation;
  int IgnoreArg_baseStation;

} CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE;

typedef struct _CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const pulseProcessor_t* Expected_state;
  pulseProcessorResult_t* Expected_angles;
  int Expected_baseStation1;
  int Expected_baseStation2;
  int Expected_state_Depth;
  int Expected_angles_Depth;
  int IgnoreArg_state;
  int IgnoreArg_angles;
  int IgnoreArg_baseStation1;
  int IgnoreArg_baseStation2;

} CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE;

typedef struct _CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const pulseProcessor_t* Expected_state;
  pulseProcessorResult_t* Expected_angles;
  int Expected_baseStation;
  int Expected_state_Depth;
  int Expected_angles_Depth;
  int IgnoreArg_state;
  int IgnoreArg_angles;
  int IgnoreArg_baseStation;

} CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE;

static struct mock_lighthouse_position_estInstance
{
  int lighthousePositionEstInit_IgnoreBool;
  CMOCK_lighthousePositionEstInit_CALLBACK lighthousePositionEstInit_CallbackFunctionPointer;
  int lighthousePositionEstInit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthousePositionEstInit_CallInstance;
  int lighthousePositionSetGeometryData_IgnoreBool;
  CMOCK_lighthousePositionSetGeometryData_CALLBACK lighthousePositionSetGeometryData_CallbackFunctionPointer;
  int lighthousePositionSetGeometryData_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthousePositionSetGeometryData_CallInstance;
  int lighthousePositionCalibrationDataWritten_IgnoreBool;
  CMOCK_lighthousePositionCalibrationDataWritten_CALLBACK lighthousePositionCalibrationDataWritten_CallbackFunctionPointer;
  int lighthousePositionCalibrationDataWritten_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthousePositionCalibrationDataWritten_CallInstance;
  int lighthousePositionEstimatePoseCrossingBeams_IgnoreBool;
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALLBACK lighthousePositionEstimatePoseCrossingBeams_CallbackFunctionPointer;
  int lighthousePositionEstimatePoseCrossingBeams_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthousePositionEstimatePoseCrossingBeams_CallInstance;
  int lighthousePositionEstimatePoseSweeps_IgnoreBool;
  CMOCK_lighthousePositionEstimatePoseSweeps_CALLBACK lighthousePositionEstimatePoseSweeps_CallbackFunctionPointer;
  int lighthousePositionEstimatePoseSweeps_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthousePositionEstimatePoseSweeps_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_lighthouse_position_est_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.lighthousePositionEstInit_IgnoreBool)
    Mock.lighthousePositionEstInit_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthousePositionEstInit);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthousePositionEstInit_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthousePositionEstInit_CallbackFunctionPointer != NULL)
    Mock.lighthousePositionEstInit_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthousePositionSetGeometryData_IgnoreBool)
    Mock.lighthousePositionSetGeometryData_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthousePositionSetGeometryData);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthousePositionSetGeometryData_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthousePositionSetGeometryData_CallbackFunctionPointer != NULL)
    Mock.lighthousePositionSetGeometryData_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthousePositionCalibrationDataWritten_IgnoreBool)
    Mock.lighthousePositionCalibrationDataWritten_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthousePositionCalibrationDataWritten);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthousePositionCalibrationDataWritten_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthousePositionCalibrationDataWritten_CallbackFunctionPointer != NULL)
    Mock.lighthousePositionCalibrationDataWritten_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthousePositionEstimatePoseCrossingBeams_IgnoreBool)
    Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthousePositionEstimatePoseCrossingBeams);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackFunctionPointer != NULL)
    Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthousePositionEstimatePoseSweeps_IgnoreBool)
    Mock.lighthousePositionEstimatePoseSweeps_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthousePositionEstimatePoseSweeps);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthousePositionEstimatePoseSweeps_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthousePositionEstimatePoseSweeps_CallbackFunctionPointer != NULL)
    Mock.lighthousePositionEstimatePoseSweeps_CallInstance = CMOCK_GUTS_NONE;
}

void mock_lighthouse_position_est_Init(void)
{
  mock_lighthouse_position_est_Destroy();
}

void mock_lighthouse_position_est_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.lighthousePositionEstInit_CallbackFunctionPointer = NULL;
  Mock.lighthousePositionEstInit_CallbackCalls = 0;
  Mock.lighthousePositionSetGeometryData_CallbackFunctionPointer = NULL;
  Mock.lighthousePositionSetGeometryData_CallbackCalls = 0;
  Mock.lighthousePositionCalibrationDataWritten_CallbackFunctionPointer = NULL;
  Mock.lighthousePositionCalibrationDataWritten_CallbackCalls = 0;
  Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackFunctionPointer = NULL;
  Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackCalls = 0;
  Mock.lighthousePositionEstimatePoseSweeps_CallbackFunctionPointer = NULL;
  Mock.lighthousePositionEstimatePoseSweeps_CallbackCalls = 0;
}

void lighthousePositionEstInit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthousePositionEstInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthousePositionEstInit);
  cmock_call_instance = (CMOCK_lighthousePositionEstInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthousePositionEstInit_CallInstance);
  Mock.lighthousePositionEstInit_CallInstance = CMock_Guts_MemNext(Mock.lighthousePositionEstInit_CallInstance);
  if (Mock.lighthousePositionEstInit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthousePositionEstInit_CallbackFunctionPointer != NULL)
  {
    Mock.lighthousePositionEstInit_CallbackFunctionPointer(Mock.lighthousePositionEstInit_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void lighthousePositionEstInit_CMockIgnore(void)
{
  Mock.lighthousePositionEstInit_IgnoreBool = (int)1;
}

void lighthousePositionEstInit_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionEstInit_CALL_INSTANCE));
  CMOCK_lighthousePositionEstInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionEstInit_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionEstInit_CallInstance, cmock_guts_index);
  Mock.lighthousePositionEstInit_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  UNITY_CLR_DETAILS();
}

void lighthousePositionEstInit_StubWithCallback(CMOCK_lighthousePositionEstInit_CALLBACK Callback)
{
  Mock.lighthousePositionEstInit_IgnoreBool = (int)0;
  Mock.lighthousePositionEstInit_CallbackFunctionPointer = Callback;
}

void lighthousePositionSetGeometryData(const uint8_t baseStation, const baseStationGeometry_t* geometry)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthousePositionSetGeometryData);
  cmock_call_instance = (CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthousePositionSetGeometryData_CallInstance);
  Mock.lighthousePositionSetGeometryData_CallInstance = CMock_Guts_MemNext(Mock.lighthousePositionSetGeometryData_CallInstance);
  if (Mock.lighthousePositionSetGeometryData_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthousePositionSetGeometryData_CallbackFunctionPointer != NULL)
  {
    Mock.lighthousePositionSetGeometryData_CallbackFunctionPointer(baseStation, geometry, Mock.lighthousePositionSetGeometryData_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_baseStation)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionSetGeometryData,CMockString_baseStation);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_baseStation, baseStation, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_geometry)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionSetGeometryData,CMockString_geometry);
    if (cmock_call_instance->Expected_geometry == NULL)
      { UNITY_TEST_ASSERT_NULL(geometry, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_geometry), (void*)(geometry), sizeof(const baseStationGeometry_t), cmock_call_instance->Expected_geometry_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthousePositionSetGeometryData(CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE* cmock_call_instance, const uint8_t baseStation, const baseStationGeometry_t* geometry, int geometry_Depth)
{
  cmock_call_instance->Expected_baseStation = baseStation;
  cmock_call_instance->IgnoreArg_baseStation = 0;
  cmock_call_instance->Expected_geometry = geometry;
  cmock_call_instance->Expected_geometry_Depth = geometry_Depth;
  cmock_call_instance->IgnoreArg_geometry = 0;
}

void lighthousePositionSetGeometryData_CMockIgnore(void)
{
  Mock.lighthousePositionSetGeometryData_IgnoreBool = (int)1;
}

void lighthousePositionSetGeometryData_CMockExpect(UNITY_LINE_TYPE cmock_line, const uint8_t baseStation, const baseStationGeometry_t* geometry)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE));
  CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionSetGeometryData_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionSetGeometryData_CallInstance, cmock_guts_index);
  Mock.lighthousePositionSetGeometryData_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionSetGeometryData(cmock_call_instance, baseStation, geometry, 1);
  UNITY_CLR_DETAILS();
}

void lighthousePositionSetGeometryData_StubWithCallback(CMOCK_lighthousePositionSetGeometryData_CALLBACK Callback)
{
  Mock.lighthousePositionSetGeometryData_IgnoreBool = (int)0;
  Mock.lighthousePositionSetGeometryData_CallbackFunctionPointer = Callback;
}

void lighthousePositionSetGeometryData_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const uint8_t baseStation, const baseStationGeometry_t* geometry, int geometry_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE));
  CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionSetGeometryData_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionSetGeometryData_CallInstance, cmock_guts_index);
  Mock.lighthousePositionSetGeometryData_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionSetGeometryData(cmock_call_instance, baseStation, geometry, geometry_Depth);
}

void lighthousePositionSetGeometryData_CMockIgnoreArg_baseStation(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionSetGeometryData_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_baseStation = 1;
}

void lighthousePositionSetGeometryData_CMockIgnoreArg_geometry(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionSetGeometryData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionSetGeometryData_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_geometry = 1;
}

void lighthousePositionCalibrationDataWritten(const uint8_t baseStation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthousePositionCalibrationDataWritten);
  cmock_call_instance = (CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthousePositionCalibrationDataWritten_CallInstance);
  Mock.lighthousePositionCalibrationDataWritten_CallInstance = CMock_Guts_MemNext(Mock.lighthousePositionCalibrationDataWritten_CallInstance);
  if (Mock.lighthousePositionCalibrationDataWritten_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthousePositionCalibrationDataWritten_CallbackFunctionPointer != NULL)
  {
    Mock.lighthousePositionCalibrationDataWritten_CallbackFunctionPointer(baseStation, Mock.lighthousePositionCalibrationDataWritten_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_baseStation)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionCalibrationDataWritten,CMockString_baseStation);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_baseStation, baseStation, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthousePositionCalibrationDataWritten(CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE* cmock_call_instance, const uint8_t baseStation)
{
  cmock_call_instance->Expected_baseStation = baseStation;
  cmock_call_instance->IgnoreArg_baseStation = 0;
}

void lighthousePositionCalibrationDataWritten_CMockIgnore(void)
{
  Mock.lighthousePositionCalibrationDataWritten_IgnoreBool = (int)1;
}

void lighthousePositionCalibrationDataWritten_CMockExpect(UNITY_LINE_TYPE cmock_line, const uint8_t baseStation)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE));
  CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionCalibrationDataWritten_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionCalibrationDataWritten_CallInstance, cmock_guts_index);
  Mock.lighthousePositionCalibrationDataWritten_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionCalibrationDataWritten(cmock_call_instance, baseStation);
  UNITY_CLR_DETAILS();
}

void lighthousePositionCalibrationDataWritten_StubWithCallback(CMOCK_lighthousePositionCalibrationDataWritten_CALLBACK Callback)
{
  Mock.lighthousePositionCalibrationDataWritten_IgnoreBool = (int)0;
  Mock.lighthousePositionCalibrationDataWritten_CallbackFunctionPointer = Callback;
}

void lighthousePositionCalibrationDataWritten_CMockIgnoreArg_baseStation(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionCalibrationDataWritten_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionCalibrationDataWritten_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_baseStation = 1;
}

void lighthousePositionEstimatePoseCrossingBeams(const pulseProcessor_t* state, pulseProcessorResult_t* angles, int baseStation1, int baseStation2)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthousePositionEstimatePoseCrossingBeams);
  cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance);
  Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance = CMock_Guts_MemNext(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance);
  if (Mock.lighthousePositionEstimatePoseCrossingBeams_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackFunctionPointer != NULL)
  {
    Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackFunctionPointer(state, angles, baseStation1, baseStation2, Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_state)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseCrossingBeams,CMockString_state);
    if (cmock_call_instance->Expected_state == NULL)
      { UNITY_TEST_ASSERT_NULL(state, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_state), (void*)(state), sizeof(const pulseProcessor_t), cmock_call_instance->Expected_state_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_angles)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseCrossingBeams,CMockString_angles);
    if (cmock_call_instance->Expected_angles == NULL)
      { UNITY_TEST_ASSERT_NULL(angles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_angles), (void*)(angles), sizeof(pulseProcessorResult_t), cmock_call_instance->Expected_angles_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_baseStation1)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseCrossingBeams,CMockString_baseStation1);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_baseStation1, baseStation1, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_baseStation2)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseCrossingBeams,CMockString_baseStation2);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_baseStation2, baseStation2, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthousePositionEstimatePoseCrossingBeams(CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance, const pulseProcessor_t* state, int state_Depth, pulseProcessorResult_t* angles, int angles_Depth, int baseStation1, int baseStation2)
{
  cmock_call_instance->Expected_state = state;
  cmock_call_instance->Expected_state_Depth = state_Depth;
  cmock_call_instance->IgnoreArg_state = 0;
  cmock_call_instance->Expected_angles = angles;
  cmock_call_instance->Expected_angles_Depth = angles_Depth;
  cmock_call_instance->IgnoreArg_angles = 0;
  cmock_call_instance->Expected_baseStation1 = baseStation1;
  cmock_call_instance->IgnoreArg_baseStation1 = 0;
  cmock_call_instance->Expected_baseStation2 = baseStation2;
  cmock_call_instance->IgnoreArg_baseStation2 = 0;
}

void lighthousePositionEstimatePoseCrossingBeams_CMockIgnore(void)
{
  Mock.lighthousePositionEstimatePoseCrossingBeams_IgnoreBool = (int)1;
}

void lighthousePositionEstimatePoseCrossingBeams_CMockExpect(UNITY_LINE_TYPE cmock_line, const pulseProcessor_t* state, pulseProcessorResult_t* angles, int baseStation1, int baseStation2)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE));
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance, cmock_guts_index);
  Mock.lighthousePositionEstimatePoseCrossingBeams_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionEstimatePoseCrossingBeams(cmock_call_instance, state, 1, angles, 1, baseStation1, baseStation2);
  UNITY_CLR_DETAILS();
}

void lighthousePositionEstimatePoseCrossingBeams_StubWithCallback(CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALLBACK Callback)
{
  Mock.lighthousePositionEstimatePoseCrossingBeams_IgnoreBool = (int)0;
  Mock.lighthousePositionEstimatePoseCrossingBeams_CallbackFunctionPointer = Callback;
}

void lighthousePositionEstimatePoseCrossingBeams_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const pulseProcessor_t* state, int state_Depth, pulseProcessorResult_t* angles, int angles_Depth, int baseStation1, int baseStation2)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE));
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance, cmock_guts_index);
  Mock.lighthousePositionEstimatePoseCrossingBeams_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionEstimatePoseCrossingBeams(cmock_call_instance, state, state_Depth, angles, angles_Depth, baseStation1, baseStation2);
}

void lighthousePositionEstimatePoseCrossingBeams_CMockIgnoreArg_state(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_state = 1;
}

void lighthousePositionEstimatePoseCrossingBeams_CMockIgnoreArg_angles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_angles = 1;
}

void lighthousePositionEstimatePoseCrossingBeams_CMockIgnoreArg_baseStation1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_baseStation1 = 1;
}

void lighthousePositionEstimatePoseCrossingBeams_CMockIgnoreArg_baseStation2(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseCrossingBeams_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseCrossingBeams_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_baseStation2 = 1;
}

void lighthousePositionEstimatePoseSweeps(const pulseProcessor_t* state, pulseProcessorResult_t* angles, int baseStation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthousePositionEstimatePoseSweeps);
  cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthousePositionEstimatePoseSweeps_CallInstance);
  Mock.lighthousePositionEstimatePoseSweeps_CallInstance = CMock_Guts_MemNext(Mock.lighthousePositionEstimatePoseSweeps_CallInstance);
  if (Mock.lighthousePositionEstimatePoseSweeps_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (Mock.lighthousePositionEstimatePoseSweeps_CallbackFunctionPointer != NULL)
  {
    Mock.lighthousePositionEstimatePoseSweeps_CallbackFunctionPointer(state, angles, baseStation, Mock.lighthousePositionEstimatePoseSweeps_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_state)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseSweeps,CMockString_state);
    if (cmock_call_instance->Expected_state == NULL)
      { UNITY_TEST_ASSERT_NULL(state, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_state), (void*)(state), sizeof(const pulseProcessor_t), cmock_call_instance->Expected_state_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_angles)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseSweeps,CMockString_angles);
    if (cmock_call_instance->Expected_angles == NULL)
      { UNITY_TEST_ASSERT_NULL(angles, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_angles), (void*)(angles), sizeof(pulseProcessorResult_t), cmock_call_instance->Expected_angles_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_baseStation)
  {
    UNITY_SET_DETAILS(CMockString_lighthousePositionEstimatePoseSweeps,CMockString_baseStation);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_baseStation, baseStation, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_lighthousePositionEstimatePoseSweeps(CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance, const pulseProcessor_t* state, int state_Depth, pulseProcessorResult_t* angles, int angles_Depth, int baseStation)
{
  cmock_call_instance->Expected_state = state;
  cmock_call_instance->Expected_state_Depth = state_Depth;
  cmock_call_instance->IgnoreArg_state = 0;
  cmock_call_instance->Expected_angles = angles;
  cmock_call_instance->Expected_angles_Depth = angles_Depth;
  cmock_call_instance->IgnoreArg_angles = 0;
  cmock_call_instance->Expected_baseStation = baseStation;
  cmock_call_instance->IgnoreArg_baseStation = 0;
}

void lighthousePositionEstimatePoseSweeps_CMockIgnore(void)
{
  Mock.lighthousePositionEstimatePoseSweeps_IgnoreBool = (int)1;
}

void lighthousePositionEstimatePoseSweeps_CMockExpect(UNITY_LINE_TYPE cmock_line, const pulseProcessor_t* state, pulseProcessorResult_t* angles, int baseStation)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE));
  CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionEstimatePoseSweeps_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionEstimatePoseSweeps_CallInstance, cmock_guts_index);
  Mock.lighthousePositionEstimatePoseSweeps_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionEstimatePoseSweeps(cmock_call_instance, state, 1, angles, 1, baseStation);
  UNITY_CLR_DETAILS();
}

void lighthousePositionEstimatePoseSweeps_StubWithCallback(CMOCK_lighthousePositionEstimatePoseSweeps_CALLBACK Callback)
{
  Mock.lighthousePositionEstimatePoseSweeps_IgnoreBool = (int)0;
  Mock.lighthousePositionEstimatePoseSweeps_CallbackFunctionPointer = Callback;
}

void lighthousePositionEstimatePoseSweeps_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const pulseProcessor_t* state, int state_Depth, pulseProcessorResult_t* angles, int angles_Depth, int baseStation)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE));
  CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthousePositionEstimatePoseSweeps_CallInstance = CMock_Guts_MemChain(Mock.lighthousePositionEstimatePoseSweeps_CallInstance, cmock_guts_index);
  Mock.lighthousePositionEstimatePoseSweeps_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthousePositionEstimatePoseSweeps(cmock_call_instance, state, state_Depth, angles, angles_Depth, baseStation);
}

void lighthousePositionEstimatePoseSweeps_CMockIgnoreArg_state(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseSweeps_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_state = 1;
}

void lighthousePositionEstimatePoseSweeps_CMockIgnoreArg_angles(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseSweeps_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_angles = 1;
}

void lighthousePositionEstimatePoseSweeps_CMockIgnoreArg_baseStation(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthousePositionEstimatePoseSweeps_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthousePositionEstimatePoseSweeps_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_baseStation = 1;
}

