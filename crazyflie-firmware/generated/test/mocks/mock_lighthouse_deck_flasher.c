/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_lighthouse_deck_flasher.h"

static const char* CMockString_buffer = "buffer";
static const char* CMockString_lighthouseDeckFlasherCheckVersionAndBoot = "lighthouseDeckFlasherCheckVersionAndBoot";
static const char* CMockString_lighthouseDeckFlasherPropertiesQuery = "lighthouseDeckFlasherPropertiesQuery";
static const char* CMockString_lighthouseDeckFlasherRead = "lighthouseDeckFlasherRead";
static const char* CMockString_lighthouseDeckFlasherWrite = "lighthouseDeckFlasherWrite";
static const char* CMockString_memAddr = "memAddr";
static const char* CMockString_memDef = "memDef";
static const char* CMockString_readLen = "readLen";
static const char* CMockString_writeLen = "writeLen";

typedef struct _CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;

} CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;
  uint32_t Expected_memAddr;
  uint8_t Expected_readLen;
  uint8_t* Expected_buffer;
  int Expected_buffer_Depth;
  int IgnoreArg_memAddr;
  int IgnoreArg_readLen;
  int IgnoreArg_buffer;

} CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool ReturnVal;
  uint32_t Expected_memAddr;
  uint8_t Expected_writeLen;
  const uint8_t* Expected_buffer;
  const DeckMemDef_t* Expected_memDef;
  int Expected_buffer_Depth;
  int Expected_memDef_Depth;
  int IgnoreArg_memAddr;
  int IgnoreArg_writeLen;
  int IgnoreArg_buffer;
  int IgnoreArg_memDef;

} CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE;

typedef struct _CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE;

static struct mock_lighthouse_deck_flasherInstance
{
  int lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool;
  bool lighthouseDeckFlasherCheckVersionAndBoot_FinalReturn;
  CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALLBACK lighthouseDeckFlasherCheckVersionAndBoot_CallbackFunctionPointer;
  int lighthouseDeckFlasherCheckVersionAndBoot_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseDeckFlasherCheckVersionAndBoot_CallInstance;
  int lighthouseDeckFlasherRead_IgnoreBool;
  bool lighthouseDeckFlasherRead_FinalReturn;
  CMOCK_lighthouseDeckFlasherRead_CALLBACK lighthouseDeckFlasherRead_CallbackFunctionPointer;
  int lighthouseDeckFlasherRead_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseDeckFlasherRead_CallInstance;
  int lighthouseDeckFlasherWrite_IgnoreBool;
  bool lighthouseDeckFlasherWrite_FinalReturn;
  CMOCK_lighthouseDeckFlasherWrite_CALLBACK lighthouseDeckFlasherWrite_CallbackFunctionPointer;
  int lighthouseDeckFlasherWrite_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseDeckFlasherWrite_CallInstance;
  int lighthouseDeckFlasherPropertiesQuery_IgnoreBool;
  uint8_t lighthouseDeckFlasherPropertiesQuery_FinalReturn;
  CMOCK_lighthouseDeckFlasherPropertiesQuery_CALLBACK lighthouseDeckFlasherPropertiesQuery_CallbackFunctionPointer;
  int lighthouseDeckFlasherPropertiesQuery_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lighthouseDeckFlasherPropertiesQuery_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_lighthouse_deck_flasher_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool)
    Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherCheckVersionAndBoot);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackFunctionPointer != NULL)
    Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseDeckFlasherRead_IgnoreBool)
    Mock.lighthouseDeckFlasherRead_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherRead);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseDeckFlasherRead_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseDeckFlasherRead_CallbackFunctionPointer != NULL)
    Mock.lighthouseDeckFlasherRead_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseDeckFlasherWrite_IgnoreBool)
    Mock.lighthouseDeckFlasherWrite_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherWrite);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseDeckFlasherWrite_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseDeckFlasherWrite_CallbackFunctionPointer != NULL)
    Mock.lighthouseDeckFlasherWrite_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lighthouseDeckFlasherPropertiesQuery_IgnoreBool)
    Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherPropertiesQuery);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance, cmock_line, CMockStringCalledLess);
  if (Mock.lighthouseDeckFlasherPropertiesQuery_CallbackFunctionPointer != NULL)
    Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance = CMOCK_GUTS_NONE;
}

void mock_lighthouse_deck_flasher_Init(void)
{
  mock_lighthouse_deck_flasher_Destroy();
}

void mock_lighthouse_deck_flasher_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackFunctionPointer = NULL;
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackCalls = 0;
  Mock.lighthouseDeckFlasherRead_CallbackFunctionPointer = NULL;
  Mock.lighthouseDeckFlasherRead_CallbackCalls = 0;
  Mock.lighthouseDeckFlasherWrite_CallbackFunctionPointer = NULL;
  Mock.lighthouseDeckFlasherWrite_CallbackCalls = 0;
  Mock.lighthouseDeckFlasherPropertiesQuery_CallbackFunctionPointer = NULL;
  Mock.lighthouseDeckFlasherPropertiesQuery_CallbackCalls = 0;
}

bool lighthouseDeckFlasherCheckVersionAndBoot(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherCheckVersionAndBoot);
  cmock_call_instance = (CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance);
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance = CMock_Guts_MemNext(Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance);
  if (Mock.lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lighthouseDeckFlasherCheckVersionAndBoot_FinalReturn;
    Mock.lighthouseDeckFlasherCheckVersionAndBoot_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackFunctionPointer != NULL)
  {
    return Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackFunctionPointer(Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lighthouseDeckFlasherCheckVersionAndBoot_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool = (int)1;
}

void lighthouseDeckFlasherCheckVersionAndBoot_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  UNITY_CLR_DETAILS();
}

void lighthouseDeckFlasherCheckVersionAndBoot_StubWithCallback(CMOCK_lighthouseDeckFlasherCheckVersionAndBoot_CALLBACK Callback)
{
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_IgnoreBool = (int)0;
  Mock.lighthouseDeckFlasherCheckVersionAndBoot_CallbackFunctionPointer = Callback;
}

bool lighthouseDeckFlasherRead(const uint32_t memAddr, const uint8_t readLen, uint8_t* buffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherRead);
  cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseDeckFlasherRead_CallInstance);
  Mock.lighthouseDeckFlasherRead_CallInstance = CMock_Guts_MemNext(Mock.lighthouseDeckFlasherRead_CallInstance);
  if (Mock.lighthouseDeckFlasherRead_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lighthouseDeckFlasherRead_FinalReturn;
    Mock.lighthouseDeckFlasherRead_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.lighthouseDeckFlasherRead_CallbackFunctionPointer != NULL)
  {
    return Mock.lighthouseDeckFlasherRead_CallbackFunctionPointer(memAddr, readLen, buffer, Mock.lighthouseDeckFlasherRead_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_memAddr)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherRead,CMockString_memAddr);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_memAddr, memAddr, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_readLen)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherRead,CMockString_readLen);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_readLen, readLen, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_buffer)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherRead,CMockString_buffer);
    if (cmock_call_instance->Expected_buffer == NULL)
      { UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, cmock_call_instance->Expected_buffer_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lighthouseDeckFlasherRead(CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance, const uint32_t memAddr, const uint8_t readLen, uint8_t* buffer, int buffer_Depth)
{
  cmock_call_instance->Expected_memAddr = memAddr;
  cmock_call_instance->IgnoreArg_memAddr = 0;
  cmock_call_instance->Expected_readLen = readLen;
  cmock_call_instance->IgnoreArg_readLen = 0;
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_buffer_Depth = buffer_Depth;
  cmock_call_instance->IgnoreArg_buffer = 0;
}

void lighthouseDeckFlasherRead_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherRead_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherRead_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherRead_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lighthouseDeckFlasherRead_IgnoreBool = (int)1;
}

void lighthouseDeckFlasherRead_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const uint32_t memAddr, const uint8_t readLen, uint8_t* buffer, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherRead_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherRead_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherRead_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseDeckFlasherRead(cmock_call_instance, memAddr, readLen, buffer, 1);
  cmock_call_instance->ReturnVal = cmock_to_return;
  UNITY_CLR_DETAILS();
}

void lighthouseDeckFlasherRead_StubWithCallback(CMOCK_lighthouseDeckFlasherRead_CALLBACK Callback)
{
  Mock.lighthouseDeckFlasherRead_IgnoreBool = (int)0;
  Mock.lighthouseDeckFlasherRead_CallbackFunctionPointer = Callback;
}

void lighthouseDeckFlasherRead_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const uint32_t memAddr, const uint8_t readLen, uint8_t* buffer, int buffer_Depth, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherRead_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherRead_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherRead_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseDeckFlasherRead(cmock_call_instance, memAddr, readLen, buffer, buffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lighthouseDeckFlasherRead_CMockIgnoreArg_memAddr(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherRead_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_memAddr = 1;
}

void lighthouseDeckFlasherRead_CMockIgnoreArg_readLen(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherRead_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_readLen = 1;
}

void lighthouseDeckFlasherRead_CMockIgnoreArg_buffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherRead_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_buffer = 1;
}

bool lighthouseDeckFlasherWrite(const uint32_t memAddr, const uint8_t writeLen, const uint8_t* buffer, const DeckMemDef_t* memDef)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherWrite);
  cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseDeckFlasherWrite_CallInstance);
  Mock.lighthouseDeckFlasherWrite_CallInstance = CMock_Guts_MemNext(Mock.lighthouseDeckFlasherWrite_CallInstance);
  if (Mock.lighthouseDeckFlasherWrite_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lighthouseDeckFlasherWrite_FinalReturn;
    Mock.lighthouseDeckFlasherWrite_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.lighthouseDeckFlasherWrite_CallbackFunctionPointer != NULL)
  {
    return Mock.lighthouseDeckFlasherWrite_CallbackFunctionPointer(memAddr, writeLen, buffer, memDef, Mock.lighthouseDeckFlasherWrite_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->IgnoreArg_memAddr)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherWrite,CMockString_memAddr);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_memAddr, memAddr, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_writeLen)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherWrite,CMockString_writeLen);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_writeLen, writeLen, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_buffer)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherWrite,CMockString_buffer);
    if (cmock_call_instance->Expected_buffer == NULL)
      { UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, cmock_call_instance->Expected_buffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_memDef)
  {
    UNITY_SET_DETAILS(CMockString_lighthouseDeckFlasherWrite,CMockString_memDef);
    if (cmock_call_instance->Expected_memDef == NULL)
      { UNITY_TEST_ASSERT_NULL(memDef, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_memDef), (void*)(memDef), sizeof(const DeckMemDef_t), cmock_call_instance->Expected_memDef_Depth, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lighthouseDeckFlasherWrite(CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance, const uint32_t memAddr, const uint8_t writeLen, const uint8_t* buffer, int buffer_Depth, const DeckMemDef_t* memDef, int memDef_Depth)
{
  cmock_call_instance->Expected_memAddr = memAddr;
  cmock_call_instance->IgnoreArg_memAddr = 0;
  cmock_call_instance->Expected_writeLen = writeLen;
  cmock_call_instance->IgnoreArg_writeLen = 0;
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_buffer_Depth = buffer_Depth;
  cmock_call_instance->IgnoreArg_buffer = 0;
  cmock_call_instance->Expected_memDef = memDef;
  cmock_call_instance->Expected_memDef_Depth = memDef_Depth;
  cmock_call_instance->IgnoreArg_memDef = 0;
}

void lighthouseDeckFlasherWrite_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherWrite_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherWrite_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherWrite_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lighthouseDeckFlasherWrite_IgnoreBool = (int)1;
}

void lighthouseDeckFlasherWrite_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const uint32_t memAddr, const uint8_t writeLen, const uint8_t* buffer, const DeckMemDef_t* memDef, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherWrite_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherWrite_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherWrite_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseDeckFlasherWrite(cmock_call_instance, memAddr, writeLen, buffer, 1, memDef, 1);
  cmock_call_instance->ReturnVal = cmock_to_return;
  UNITY_CLR_DETAILS();
}

void lighthouseDeckFlasherWrite_StubWithCallback(CMOCK_lighthouseDeckFlasherWrite_CALLBACK Callback)
{
  Mock.lighthouseDeckFlasherWrite_IgnoreBool = (int)0;
  Mock.lighthouseDeckFlasherWrite_CallbackFunctionPointer = Callback;
}

void lighthouseDeckFlasherWrite_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const uint32_t memAddr, const uint8_t writeLen, const uint8_t* buffer, int buffer_Depth, const DeckMemDef_t* memDef, int memDef_Depth, bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherWrite_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherWrite_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherWrite_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lighthouseDeckFlasherWrite(cmock_call_instance, memAddr, writeLen, buffer, buffer_Depth, memDef, memDef_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lighthouseDeckFlasherWrite_CMockIgnoreArg_memAddr(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherWrite_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_memAddr = 1;
}

void lighthouseDeckFlasherWrite_CMockIgnoreArg_writeLen(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherWrite_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_writeLen = 1;
}

void lighthouseDeckFlasherWrite_CMockIgnoreArg_buffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherWrite_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_buffer = 1;
}

void lighthouseDeckFlasherWrite_CMockIgnoreArg_memDef(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.lighthouseDeckFlasherWrite_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_memDef = 1;
}

uint8_t lighthouseDeckFlasherPropertiesQuery(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lighthouseDeckFlasherPropertiesQuery);
  cmock_call_instance = (CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance);
  Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance = CMock_Guts_MemNext(Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance);
  if (Mock.lighthouseDeckFlasherPropertiesQuery_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.lighthouseDeckFlasherPropertiesQuery_FinalReturn;
    Mock.lighthouseDeckFlasherPropertiesQuery_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.lighthouseDeckFlasherPropertiesQuery_CallbackFunctionPointer != NULL)
  {
    return Mock.lighthouseDeckFlasherPropertiesQuery_CallbackFunctionPointer(Mock.lighthouseDeckFlasherPropertiesQuery_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lighthouseDeckFlasherPropertiesQuery_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherPropertiesQuery_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lighthouseDeckFlasherPropertiesQuery_IgnoreBool = (int)1;
}

void lighthouseDeckFlasherPropertiesQuery_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE));
  CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE* cmock_call_instance = (CMOCK_lighthouseDeckFlasherPropertiesQuery_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance = CMock_Guts_MemChain(Mock.lighthouseDeckFlasherPropertiesQuery_CallInstance, cmock_guts_index);
  Mock.lighthouseDeckFlasherPropertiesQuery_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  UNITY_CLR_DETAILS();
}

void lighthouseDeckFlasherPropertiesQuery_StubWithCallback(CMOCK_lighthouseDeckFlasherPropertiesQuery_CALLBACK Callback)
{
  Mock.lighthouseDeckFlasherPropertiesQuery_IgnoreBool = (int)0;
  Mock.lighthouseDeckFlasherPropertiesQuery_CallbackFunctionPointer = Callback;
}

